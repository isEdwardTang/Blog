---
layout: post
title: "数据挖掘之numpy基础"
categories: DataMining
tags:	python primer datamining
author: Edward
---

* content
{:toc}

数据挖掘的第一步，就是新熟悉好python中的各种科学计算的库，先从最基本的numpy库开始。

--------------------


## 一、多维数组对象

numpy中特有的对象(ndarray)，可以对这种数组的所有数据同时执行操作。

### 1、创建ndarray

使用array函数，可以接受一切序列型的对象，如下：

```python
arr1 = np.array([6, 1, 3])	# 使用list
arr2 = np.array([[1, 2, 3], [4, 5, 6]])	# 使用嵌套list，生成多维数组
```

使用asarray函数，默认array是直接拷贝各个元素，而asarray是引用，对其的改变会反映到原list：

```python
lst = [1, 3]
arr = np.asarray(lst)
arr[0] = 999	# array([999, 3]，同时lst=[999, 3]
```

使用zeros函数，可以创建全0数组：

```python
arr1 = np.zeros(10)	# 长度为10
arr2 = np.zeros((2,3))	# 接收一个元祖，生成2行3列的全0数组
```

使用zeros_like函数，创建一个和参数数组的维度大小一样的全0数组：

```python
arr1 = np.array([3, 4, 5]
arr2 = np.zeros_like(arr1)	# array([0, 0, 0])
```

使用ones和ones_like函数，可以创建全1数组，和zeros用法类似。

使用empty和empty_like函数，可以创建一个没有值的数组(初始值是不确定的垃圾值)，用法和zeros类似。

使用full和full_like函数，可以创建全为指定值的数组。

使用arange函数，类似于内置的range，但是返回的是一个ndarray而不是list：

```python
arr1 = np.arange(5)	# array([0, 1, 2, 3, 4])
```

使用identity创建一个N*N的单位矩阵：

```python
arr = np.identity(3)
"""
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]]
"""
```

使用eye同样可以实现identity的功能，但是eye可以指定M行N列的数组，并可以指定对角线的位置：
`eye(N[, M, k, dtype])`k默认为0,表示主对角线，正数时表示上方的对角线，负数时表示下方的对角线

### 2、常见属性

- ndarray.shape: 表示各个维度大小的元祖
- ndarray.dtype：数组中的数据类型
- ndarray.ndim：维度数量

重点理解一下dtype，这个可以表示numpy中特定的数据类型，同时所有创建array的方法都提供了一个dtype的参数，用于指定元素的类型。

numpy中存在的数据类型有以下：
- int8, uint8, int16, uint16, int32, uint32, int64, uint64
- float16, float32, float64, float128
- complex64, complex128, complex256
- bool
- object
- string_，固定长度的字符串(每个字符1个字节)如s10表示长度为10的字符串
- unicode_，每个字符的字节数和平台有关

### 3、数组和标量之间的运算

数组和标量的运算会应用到每一个数组的元素：

```python
arr = np.array([[1, 2, 3], 
		[4, 5, 6]])
arr * arr
"""
[[1 , 4 , 9 ],
 [16, 25, 36]]
"""

arr - arr
"""
[[0, 0, 0],
 [0, 0, 0]]
"""

1 / arr
"""
[[1.  , 0.5, 0.3333],
 [0.25, 0.2, 0.1667]]
"""

arr ** 0.5
"""
[[1., 1.4142, 1.7321],
 [2., 2.2361, 2.4495]]
"""
```

### 4、索引和切片

索引切片的使用和list类似，但是有以下区别：

- 可以直接给切片赋值，其会作用到每一个元素：

```python
arr = np.arange(10)
arr[5:8] = 12	
```

- 数组切片是原始数组的视图，视图上的任何修改会作用到源数组上

```python
arr = np.arange(10)
arr_slice = arr{5:8]
arr_slice[1] = 12345
# arr = array([0, 1, 2, 3, 4, 12345, 12345, 12345, 8, 9])
```

如果想要得到的是副本而不是视图，可以使用copy()方法。

对于多维数组的访问，可以使用逗号隔开的索引列表来获取单个元素：

```python
arr2d = np.array([1, 2, 3], [4, 5, 6]])
arr2d[0, 2] # 等价于arr2d[0][2]
```

同时，可以混合使用切片和索引：

```python
arr2d[1, :2]
```

使用:可以获取整个轴

- 布尔型索引：

对整个数组进行逻辑判断，即可得到一个bool数组:

```python
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will])
names == 'Bob'
"""
array([True, False, False, True, False])
"""
```

使用布尔型索引直接筛选元素，比如使数组中所有负数设置为0：`data[data < 0] = 0`

- Fancy Indexing：

传入一个用于指定特定顺序的整数列表或者ndarray，可以按照特定顺序选取行子集，比如：`arr[[4, 3, 0, 6]]`可以依次获取第四、三、零、六行的元素，并构成一个新的ndarray。

使用负数可以从最后一行开始获取。

如果传入两个列表，则第二个列表表示的是列号，则最后获取的是单个元素构成的行，而不是一个区域，要想获取一个方形区域，使用np.ix_函数：`arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])]`，等同于：`arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]`

注意，fancy indexing获得的永远只是源数组的copy，而不是view。

### 5、数组转置和轴变换

使用.T属性，可以获得数组的转置数组，比如获得矩阵的内积：`np.dot(arr.T, arr)`。

使用transpose也可以获得转置：`np.transpose(arr)`或者`arr.transpose()`，而对于多维数组的转置，需要传入一个由轴编号构成的元祖，标志了转置之后的轴的顺序：

```python
arr = np.arange(16).reshape(2, 2, 4)
"""
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])
"""

arr.transpose((1, 0, 2))
"""
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],

       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])
"""
```

这里要把第二个轴看成一个整体，进行变换。

使用swapaxes()方法，传入一对轴编号，对轴进行对换，这里获得的是源数据的视图:`arr.swapaxes(0, 1)`

## 二、通用函数

ufunc是一种对ndarray中的数据执行元素级运算的函数，比如：

```python
arr = np.arange(10)
np.sqrt(arr)
"""
array([ 0.        ,  1.        ,  1.41421356,  1.73205081,  2.        ,
        2.23606798,  2.44948974,  2.64575131,  2.82842712,  3.        ])
"""
```

这里总结常用的ufunc：

一元ufunc：

| 函数 | 说明 |
| :----- | :------ |
| abs、fabs | 计算整数、浮点数或复数的绝对值。对于非复数值，fabs更快 |
| sqrt | 计算各元素平方根，相当于 arr ** 0.5 |
| square | 计算各元素的平方，相当于 arr ×× 2 |
| exp | 计算各元素的指数 e<sup>x |
| log、log10、log2、log1p | 分别计算自然对数、底数为10、底数为2的log、log(1+x) |
| sign | 计算各元素的正负号 |
| ceil | 计算各元素大于等于该元素的最小整数 |
| floor | 计算各元素小于等于该元素的最大整数 |
| rint | 计算各元素的四舍五入的整数，保留dtype |
| modf | 将各个元素的小数和整数部分以两个独立数组的形式返回 |
| isnan | 返回一个表示非数字的bool型数组 |
| isfinite、isinf | 返回表示有穷的、无穷的bool型数组 |
| cos、cosh、sin、sinh、tan、tanh | 普通型和双曲型三角函数 |
| arccos、arccosh、arcsin、acrsinh、arctan、arctanh | 反三角函数 |
| logical_not | 计算各元素not x的真值 |

二元ufunc：

| 函数 | 说明 |
| :----- | :------ |
| add、subtract、multiply、divide | 将数组中对应的元素相加、减、乘、除 |
| floor_divide | 向下整除 |
| power | 对第一个数组中的元素，按照第二个数组中的相应元素计算次方 |
| maximum、fmax | 元素级的最大值计算，fmax将忽略NaN |
| minimum、fmin | 元素级的最小值计算，fmin将忽略NaN |
| mod | 求模 |
| copysign | 将第二个数组的符号复制给第一个数组的各个元素 |
| greater、greater_equal、less、equal、not_eqial | 元素级的比较运算，返回一个bool型数组，相当于>、>=、<、<=、==、!= |
| logical_and、logical_or、logical_xor | 元素级的逻辑运算，相当于&、|、^ |


## 三、使用数组进行数据处理

用numpy数组表达式代替循环或者python中原生的方法，可以快上几个数量级，除此之外，还有以下方法可供替换：

- 使用where函数替换三元表达式：

`[(x if c else y) for x, y, c in zip(xarr, yarr, cond)]`改为`np.where(cond, xarr, yarr)`，其中，第二个参数和第三个参数可以是标量值，如把所有正值替换为2，负值替换为-2,：`np.where(arr > 0, 2, -2)`

- 使用基本统计方法：

列出numpy中基本的数组统计方法：

| 方法 | 说明 |
| :--- | :--- |
| sum | 对全部或某轴向的数组求和，0长度为0 |
| mean | 求算术平均值，0长度为NaN |
| std、var | 求标准差、方差，自由度默认为n |
| min、max | 最大值和最小值 |
| argmin、argmax | 最大值和最小值的索引 |
| cumsum | 各元素的累计和 |
| cumprod | 各元素的累计积 |

- 使用bool型数组的方法：

使用sum计算真值个数，使用any、all测试存在真值和全为真值

- 使用排序：

使用`arr.sort(axis)` 方法对数组排序，或者某一个轴排序

注意np.sort()返回已排序的副本，而使用arr.sort()会修改本身

- 使用numpy中的集合运算：

列出numpy中的集合函数

| 方法 | 说明 |
| :--- | :--- |
| unique(x) | 去除重复后排序 |
| intersect1d(x, y) | 计算x和y的交集并排序 |
| union1d(x, y) | 计算x和y的并集病排序 |
| in1d(x, y) | 计算x的各元素包含于y的bool型数组 |
| setdiff1d(x, y) | 计算x和y的差集 |
| setxor1d(x, y) | 计算x和y的对称差 |

## 四、文件输入输出

- np.save(fname, arr) 以未压缩方式保存数组至.npy文件中
- np.load(fname) 读取文件返回数组
- np.savez(fname, key1=arr1, key2=arr2, ...) 保存多个数组至.npz压缩文件中，返回一个字典对象，使用其延迟加载获取各个数组
- np.savetxt(fname, delimiter) 使用分隔符分隔各元素保存数组
- np.loadtxt(fname, delimiter) 加载数组

五、线性代数

numpy.linalg库提供了一系列关于矩阵运算的方法：

| 函数 | 说明 |
| :--- | :--- |



六、生成随机数

numpy.random模块提供了高效生成各种概率分布样本值的函数，且和python的random相比，能一次生成大量样本值，部分方法如下：

| 函数 | 说明 |
| :--- | :--- |










