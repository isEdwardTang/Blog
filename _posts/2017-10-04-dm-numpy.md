---
layout: post
title: "数据挖掘之numpy基础"
categories: DataMining
tags:	python primer datamining
author: Edward
---

* content
{:toc}

数据挖掘的第一步，就是新熟悉好python中的各种科学计算的库，先从最基本的numpy库开始。

--------------------


## 一、多维数组对象

numpy中特有的对象(ndarray)，可以对这种数组的所有数据同时执行操作。

### 1、创建ndarray

使用array函数，可以接受一切序列型的对象，如下：

```python
arr1 = np.array([6, 1, 3])	# 使用list
arr2 = np.array([[1, 2, 3], [4, 5, 6]])	# 使用嵌套list，生成多维数组
```

使用asarray函数，默认array是直接拷贝各个元素，而asarray是引用，对其的改变会反映到原list：

```python
lst = [1, 3]
arr = np.asarray(lst)
arr[0] = 999	# array([999, 3]，同时lst=[999, 3]
```

使用zeros函数，可以创建全0数组：

```python
arr1 = np.zeros(10)	# 长度为10
arr2 = np.zeros((2,3))	# 接收一个元祖，生成2行3列的全0数组
```

使用zeros_like函数，创建一个和参数数组的维度大小一样的全0数组：

```python
arr1 = np.array([3, 4, 5]
arr2 = np.zeros_like(arr1)	# array([0, 0, 0])
```

使用ones和ones_like函数，可以创建全1数组，和zeros用法类似。

使用empty和empty_like函数，可以创建一个没有值的数组(初始值是不确定的垃圾值)，用法和zeros类似。

使用full和full_like函数，可以创建全为指定值的数组。

使用arange函数，类似于内置的range，但是返回的是一个ndarray而不是list：

```python
arr1 = np.arange(5)	# array([0, 1, 2, 3, 4])
```

使用identity创建一个N*N的单位矩阵：

```python
arr = np.identity(3)
"""
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]]
"""
```

使用eye同样可以实现identity的功能，但是eye可以指定M行N列的数组，并可以指定对角线的位置：
`eye(N[, M, k, dtype])`k默认为0,表示主对角线，正数时表示上方的对角线，负数时表示下方的对角线

### 2、常见属性

- ndarray.shape: 表示各个维度大小的元祖
- ndarray.dtype：数组中的数据类型
- ndarray.ndim：维度数量

重点理解一下dtype，这个可以表示numpy中特定的数据类型，同时所有创建array的方法都提供了一个dtype的参数，用于指定元素的类型。

numpy中存在的数据类型有以下：
- int8, uint8, int16, uint16, int32, uint32, int64, uint64
- float16, float32, float64, float128
- complex64, complex128, complex256
- bool
- object
- string_，固定长度的字符串(每个字符1个字节)如s10表示长度为10的字符串
- unicode_，每个字符的字节数和平台有关

### 3、数组和标量之间的运算

数组和标量的运算会应用到每一个数组的元素：

```python
arr = np.array([[1, 2, 3], 
		[4, 5, 6]])
arr * arr
"""
[[1 , 4 , 9 ],
 [16, 25, 36]]
"""

arr - arr
"""
[[0, 0, 0],
 [0, 0, 0]]
"""

1 / arr
"""
[[1.  , 0.5, 0.3333],
 [0.25, 0.2, 0.1667]]
"""

arr ** 0.5
"""
[[1., 1.4142, 1.7321],
 [2., 2.2361, 2.4495]]
"""
```

### 4、索引和切片

索引切片的使用和list类似，但是有以下区别：

- 可以直接给切片赋值，其会作用到每一个元素：

```python
arr = np.arange(10)
arr[5:8] = 12	
```

- 数组切片是原始数组的视图，视图上的任何修改会作用到源数组上

```python
arr = np.arange(10)
arr_slice = arr{5:8]
arr_slice[1] = 12345
# arr = array([0, 1, 2, 3, 4, 12345, 12345, 12345, 8, 9])
```

如果想要得到的是副本而不是视图，可以使用copy()方法。

对于多维数组的访问，可以使用逗号隔开的索引列表来获取单个元素：

```python
arr2d = np.array([1, 2, 3], [4, 5, 6]])
arr2d[0, 2] # 等价于arr2d[0][2]
```

同时，可以混合使用切片和索引：

```python
arr2d[1, :2]
```

使用:可以获取整个轴

- 布尔型索引：

对整个数组进行逻辑判断，即可得到一个bool数组:

```python
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will])
names == 'Bob'
"""
array([True, False, False, True, False])
"""
```

使用布尔型索引直接筛选元素，比如使数组中所有负数设置为0：`data[data < 0] = 0`

- Fancy Indexing：

传入一个用于指定特定顺序的整数列表或者ndarray，可以按照特定顺序选取行子集，比如：`arr[[4, 3, 0, 6]]`可以依次获取第四、三、零、六行的元素，并构成一个新的ndarray。

使用负数可以从最后一行开始获取。

如果传入两个列表，则第二个列表表示的是列号，则最后获取的是单个元素构成的行，而不是一个区域，要想获取一个方形区域，使用np.ix_函数：`arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])]`，等同于：`arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]`

注意，fancy indexing获得的永远只是源数组的copy，而不是view。

### 5、数组转置和轴变换

使用.T属性，可以获得数组的转置数组，比如获得矩阵的内积：`np.dot(arr.T, arr)`



获得随机数










